
(define fill_vec! (lambda (vec fill) (begin
    (define aux (lambda (v i f)
        (cond
            ((eq? i 0) 0)
            (true (let ((j (sub i 1))) (begin
                (vec_set! v j fill)
                (tail aux v j fill)))))))
    (let ((n (vec_size vec))) (aux vec n fill)))))

(define repeat (vau (count expr) denv
    (cond
        ((eq? count 1) (eval denv expr))
        ;((eq? count 1) expr)
        (true (begin
            (eval denv expr)
            (apply_wrap (repeat (sub count 1) expr) denv))))))

(define add_to_vec! (lambda (y x)
    (begin
        (define aux (lambda (a b n)
            (cond
                ((lt? n 0) 0)
                (true (begin
                    (vec_set! a n (add (vec_idx a n) (vec_idx b n)))
                    (tail aux a b (sub n 1)))))))
        (aux y x (sub (vec_size y) 1)))))

(define ary (lambda (n) 
  (let ((x (range 1 (add n 1)))
      (y (vec_new n)))
    (begin
      (fill_vec! y 0)
      (repeat 10 (add_to_vec! y x))
      (print x y)
      (list (vec_idx y 0) (vec_idx y (sub n 1)))
      ;(list (vec_idx x 0) (vec_idx x (sub n 1)))
    ))))

(define main (lambda (args)
    (let ((n 1000)) (print (ary n)))))